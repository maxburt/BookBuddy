<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>EPUB Reader</title>
    <script src="www/jszip.min.js"></script>
    <script src="www/epub.min.js"></script>
    <style>
        /* Visual gradient overlay at the top */
        #topGradient {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 64px;
          background: linear-gradient(to bottom, rgba(0, 0, 0, 0.6), transparent);
          z-index: 3;
          pointer-events: none; /* This element just provides visual feedback */
          display: block;
        }
        /* Tap zone for showing/hiding toolbar */
        #topTapZone {
          position: fixed;
          top: 0;
          width: 100%;
          height: 48px; /* adjust as needed */
          z-index: 5;
        }
        /* Back button styling */
        #backBtn {
          background: none;
          border: none;
          color: white;
          font-size: 18px;
          margin-right: 12px;
          cursor: pointer;
        }
        /* Toolbar header, initially hidden */
        #header {
          position: fixed;
          top: 0;
          width: 100%;
          height: 48px;
          background-color: #222;
          color: white;
          align-items: center;
          padding: 0 16px;
          z-index: 1000;
          font-family: sans-serif;
          display: none;
        }
        #bookTitle {
          font-weight: bold;
          font-size: 18px;
          flex: 1;
        }
        /* Table of Contents dropdown styling */
        #tocDropdown {
          background: #222;
          color: white;
          border: 1px solid #444;
          padding: 4px;
          margin-left: 8px;
        }
        html, body {
          margin: 0;
          padding: 0;
          height: 100%;
          overflow: hidden;
        }
        #viewer {
          width: 100%;
          height: calc(100% - 48px);
          margin-top: 48px;
        }
        /* Tap zones for page navigation */
        #prevTap, #nextTap {
          position: fixed;
          top: 0;
          height: 100%;
          width: 30%;
          z-index: 10;
        }
        #prevTap {
          left: 0;
        }
        #nextTap {
          right: 0;
        }
    </style>
</head>
<body>
<!-- Toolbar Header -->
<div id="header">
    <button id="backBtn">‚Üê Back</button>
    <select id="fontSizeSelect">
        <option value="80%">Small</option>
        <option value="100%" selected>Normal</option>
        <option value="120%">Large</option>
        <option value="150%">Extra Large</option>
    </select>
    <select id="tocDropdown">
        <option>Loading TOC...</option>
    </select>
</div>
<!-- Gradient overlay and tap zone -->
<div id="topGradient"></div>
<div id="topTapZone"></div>
<!-- Main viewer area -->
<div id="viewer"></div>
<!-- Page navigation tap zones -->
<div id="prevTap"></div>
<div id="nextTap"></div>
<script>
    let rendition;
    let book;
    let touchStartX = null;
    let hasInitiallyRelocated = false;

    window.loadBookBase64 = function(base64Data, savedCfi = "", fontSize = "100%") {
      const binary = atob(base64Data);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binary.charCodeAt(i);
      }

      const blob = new Blob([bytes], { type: "application/epub+zip" });
      book = ePub(blob);

      rendition = book.renderTo("viewer", {
        width: "100%",
        height: "100%",
        flow: "paginated",
        manager: "continuous"
      });

      // Set initial font size
      rendition.themes.fontSize(fontSize);
      // Update the spinner to reflect the current font size
        const fontSizeSelect = document.getElementById("fontSizeSelect");
        if (fontSizeSelect) {
          for (let i = 0; i < fontSizeSelect.options.length; i++) {
            if (fontSizeSelect.options[i].value === fontSize) {
              fontSizeSelect.selectedIndex = i;
              break;
            }
          }
        }

      // Resume reading position
      book.ready.then(() => {
        const key = `bookbuddy_location_${book.key()}`;
        const localLoc = typeof localStorage !== "undefined" ? localStorage.getItem(key) : null;
        const startCfi = savedCfi || localLoc || undefined;
        rendition.display(startCfi);
      });

      rendition.on("relocated", (location) => {
        const cfi = location.start.cfi;
        if (!hasInitiallyRelocated) {
          hasInitiallyRelocated = true;
          console.log("Initial relocation (skipping save):", cfi);
          return;
        }

        console.log("Saving new CFI:", cfi);
        const key = `bookbuddy_location_${book.key()}`;
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(key, cfi);
        }

        if (window.AndroidInterface && AndroidInterface.saveProgress) {
          AndroidInterface.saveProgress(cfi);
        }
      });

      rendition.on("rendered", () => {
        rendition.views().forEach((view) => {
          const doc = view.document;
          doc.addEventListener("touchstart", onTouchStart, false);
          doc.addEventListener("touchend", onTouchEnd, false);
        });
      });

      // Load TOC
      book.loaded.navigation.then((nav) => {
        const tocDropdown = document.getElementById("tocDropdown");
        tocDropdown.innerHTML = "";

        if (nav.toc.length === 0) {
          const noChapters = document.createElement("option");
          noChapters.textContent = "No chapters found";
          tocDropdown.appendChild(noChapters);
          return;
        }

        nav.toc.forEach((chapter) => {
          const option = document.createElement("option");
          option.textContent = chapter.label;
          option.value = chapter.href;
          tocDropdown.appendChild(option);
        });

        tocDropdown.addEventListener("change", function () {
          const href = tocDropdown.value;
          if (href && book) {
            rendition.display(href);
          }
        });
      }).catch((err) => {
        console.error("Error loading TOC:", err);
      });
    };

    function nextPage() {
      if (rendition) rendition.next();
    }
    function prevPage() {
      if (rendition) rendition.prev();
    }

    document.getElementById("prevTap").addEventListener("click", prevPage);
    document.getElementById("nextTap").addEventListener("click", nextPage);

    document.getElementById("backBtn").addEventListener("click", function () {
      if (window.AndroidInterface && AndroidInterface.onBackPressed) {
        AndroidInterface.onBackPressed();
      }
    });

    function onTouchStart(e) {
      touchStartX = e.changedTouches[0].screenX;
    }

    function onTouchEnd(e) {
      if (!touchStartX) return;
      const dx = e.changedTouches[0].screenX - touchStartX;
      if (dx > 50) prevPage();
      else if (dx < -50) nextPage();
      touchStartX = null;
    }

    let toolbarTimeout = null;
    function showToolbar() {
      document.getElementById("header").style.display = "flex";
      document.getElementById("topGradient").style.display = "block";
      if (toolbarTimeout) clearTimeout(toolbarTimeout);
      toolbarTimeout = setTimeout(() => {
        hideToolbar();
      }, 6000);
    }

    function hideToolbar() {
      document.getElementById("header").style.display = "none";
      document.getElementById("topGradient").style.display = "none";
    }

    document.getElementById("topTapZone").addEventListener("click", () => {
      const header = document.getElementById("header");
      const isVisible = header.style.display === "flex";
      if (isVisible) hideToolbar();
      else showToolbar();
    });

    let swipeStartY = null;
    document.addEventListener("touchstart", function (e) {
      swipeStartY = e.changedTouches[0].screenY;
    }, false);
    document.addEventListener("touchend", function (e) {
      if (swipeStartY === null) return;
      const dy = e.changedTouches[0].screenY - swipeStartY;
      if (dy > 50) showToolbar();
      else if (dy < -50) hideToolbar();
      swipeStartY = null;
    }, false);

    document.getElementById("fontSizeSelect").addEventListener("change", function () {
      const size = this.value;
      rendition.themes.fontSize(size);
    });
</script>
</body>
</html>